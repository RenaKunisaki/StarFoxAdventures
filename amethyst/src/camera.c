#include "main.h"

u8 cameraFlags = 0; //CameraFlags
s8 debugCameraMode = CAM_MODE_NORMAL; //CameraMode

//static void (*origFunc)(Camera *self);

//previous distance when not modifying it
static float prevDistance = 0;

//position to override camera for free/stay modes
static float camOverrideX, camOverrideY, camOverrideZ, camOverrideDist = 300;
static s16 camOverrideRX, camOverrideRY, camOverrideRZ;
static u8 camOverrideValid; //bool

//distance and angle for orbit mode
static float camOrbitDist  = 50;
static s16   camOrbitAngXZ = 0;
static s16   camOrbitAngY  = 0;

//turn camera to look at target
void _lookAtTarget() {
    vec3f targetPos;
    float targetXZ;
    cameraGetFocusObjDistance(
        cameraMtxVar57 ? cameraMtxVar57->targetHeight : 0,
        pCamera, &targetPos.x, &targetPos.y,
        &targetPos.z, &targetXZ, false);
    pCamera->pos.xf.rotation.x = -0x8000 - atan2fi(targetPos.x, targetPos.z);

    //tilt to point to player
    //(Y rotation value, even though it's local X-axis rotation...)
    pCamera->pos.xf.rotation.y = atan2fi(targetPos.y, targetXZ);
}

void _camGetStickInput(s8 *outX, s8 *outY) {
    int pad = (cameraFlags & CAM_FLAG_PAD3) ? 2 : 0;
    s8 stickX = controllerStates[pad].substickX & 0xFC;
    s8 stickY = controllerStates[pad].substickY & 0xFC;

    if(cameraFlags & CAM_FLAG_INVERT_X) stickX = -stickX;
    if(cameraFlags & CAM_FLAG_INVERT_Y) stickY = -stickY;

    if(outX) *outX = stickX;
    if(outY) *outY = stickY;
}

void _camDoRotateAroundPlayerDefault(float stickX, float stickY) {
    //get the distance from camera to target
    float height = cameraMtxVar57 ? cameraMtxVar57->targetHeight : 0;
    float dx, dy, dz, dxz;
    ObjInstance *target = NULL;
    if(!pCamera) return;
    if(pCamera->overrideTarget) target = pCamera->overrideTarget;
    else if(pCamera->target) target = pCamera->target;
    else target = pCamera->focus;

    //cameraGetFocusObjDistance(height, pCamera, &dx, &dy, &dz, &dxz, true);
    //we don't need dx and dz here but we can't pass NULL for them.

    dy = pCamera->pos.xf.pos.y - (target->pos.pos.y + height);
    float *paramsCombat = *(float**)0x803dd568;
    if(paramsCombat) {
        dxz = paramsCombat[0];
    }
    else {
        dx  = pCamera->pos.xf.pos.x -  target->pos.pos.x;
        dz  = pCamera->pos.xf.pos.z -  target->pos.pos.z;
        dxz = sqrtf((dx*dx)+(dz*dz));
    }
    //debugPrintf("dy=%f dxz=%f\n", dy, dxz);

    //calculate the angle
    s16 rx = pCamera->pos.xf.rotation.x;
    s16 ry = pCamera->pos.xf.rotation.y;
    rx += stickX * 16.0 * framesThisStep;
    ry += stickY * 16.0 * framesThisStep;
    dy += (float)stickY * (1.0 / 32.0) * framesThisStep;

    //XXX we need to figure out how the camera normally decides what distance
    //it should be. this "works" but is a number generated by my anus and
    //causes it to bounce back and forth between two points sometimes.
    //if(dxz < 30.0) dxz = 30.0;
    //this is better but still a hack
    dxz = prevDistance;

    float cosx, cosy, sinx, siny;
    sinx = sinf(pi * (rx - 0x4000) / 32768.0);
    cosx = cosf(pi * (rx - 0x4000) / 32768.0);
    siny = sinf(pi *  ry / 32768.0);
    cosy = cosf(pi *  ry / 32768.0) * dxz;

    pCamera->pos.xf.pos.x = target->pos.pos.x + cosy * cosx;
    pCamera->pos.xf.pos.y = target->pos.pos.y + height + dy;
    pCamera->pos.xf.pos.z = target->pos.pos.z + cosy * sinx;

    /*pCamera->prevPos = pCamera->pos.pos;
    pCamera->prevPos44 = pCamera->pos.pos;
    pCamera->pos_0xa8 = pCamera->pos.pos;
    pCamera->prevPos2 = pCamera->pos.pos;
    pCamera->focusOverridePos = pCamera->pos.pos;
    pCamera->firstPersonPos = pCamera->pos.pos;
    pCamera->prevRot = pCamera->pos.rotation;
    pCamera->firstPersonRot = pCamera->pos.rotation;*/
}

void _camDoRotateAroundPlayer(s8 stickX, s8 stickY) {
    /*debugPrintf("Cam zoom %f focus %f %f %f rot %d %d\n",
        pCamera->zoomTimer,
        pCamera->focus->pos.pos.x,
        pCamera->focus->pos.pos.y,
        pCamera->focus->pos.pos.z,
        pCamera->pos.rotation.x, pCamera->pos.rotation.y);*/

    //if(ABS(stickX) < 1 && ABS(stickY) < 1) return;

    void *pState = pPlayer->state;
    switch(cameraMode) {
        case 0x45: { //bike
            void *params = *(void**)0x803dd540;
            if(params) *(float*)(params+0x20) += stickX * 64;
            WRITEFLOAT(0x803e1798, 3072 + (stickY * 256));
            break;
        }
        /*case 0x49: { //combat
            //this shit is too complicated
            //this sort of works but the camera will just keep going up and up
            //WRITEFLOAT(0x803e18e8, 20+(stickY*20));
            float *params = *(float**)0x803dd568;
            if(params) {
                debugPrintf("params %08X %f %f %f %f\n", params,
                    params[0], params[1], params[2], params[6]);
                if((params[1] > -64 && stickY < 0)
                || (params[1] <  64 && stickY > 0)) {
                    params[1] = stickY * 10;
                }
                //params[6] = stickX;
            }
            //pCamera->rotFlags_0x13f = 0xFF;
            //_camDoRotateAroundPlayerDefault(stickX, 0);
            WRITE16(0x8010c5d6, ((int)stickX * 256) + 0x8000);
            WRITE16(0x8010c5e2, ((int)stickX * 256) + 0x8000);
            WRITE_NOP(0x8010c614);
            iCacheFlush((void*)0x8010c5d4, 0x8010c614 - 0x8010c5d4);
            _lookAtTarget();
            break;
        }*/
        case 0x52: { //force behind
            //update aim vector so camera isn't
            //forced behind at all times.
            float aimX = (*(float*)(pState + 0x7B8));
            float aimY = (*(float*)(pState + 0x7BC));
            aimX += stickX /  256.0;
            aimY += stickY / 1024.0;
            if(aimX < -pi) aimX += (2 * pi);
            if(aimX >  pi) aimX -= (2 * pi);
            if(aimY < -pi) aimY += (2 * pi);
            if(aimY >  pi) aimY -= (2 * pi);
            (*(float*)(pState + 0x7B8)) = aimX;
            (*(float*)(pState + 0x7BC)) = aimY;
            //let the camera circle 360 degrees, not 180
            WRITE_NOP(0x8010fda4);
            WRITE_NOP(0x8010fdb8);
            iCacheFlush((void*)0x8010fda4, 0x8010fdbc-0x8010fda4);
            break;
        }
        default:
            if(ABS(stickX) < 1 && ABS(stickY) < 1) return;
            _camDoRotateAroundPlayerDefault(stickX, stickY);
            _lookAtTarget();
            //undo 360 patch
            WRITE32(0x8010fda4, 0x7C000E70); //srawi r0,r0,0x1
            WRITE32(0x8010fdb8, 0x7C000E70); //srawi r0,r0,0x1
            iCacheFlush((void*)0x8010fda4, 0x8010fdbc-0x8010fda4);
    }
}

void _camDoCStick() {
    s8 stickX, stickY;
    _camGetStickInput(&stickX, &stickY);
    if(!bFreeMove) {
        if(!(stickX || stickY)) {
            float dx, dy, dz;
            float height = cameraMtxVar57 ? cameraMtxVar57->targetHeight : 0;
            cameraGetFocusObjDistance(height,
                pCamera, &dx, &dy, &dz, &prevDistance, true);
        }
        float scale = 1;
        if(debugCameraMode == CAM_MODE_BIRD
        || debugCameraMode == CAM_MODE_FIRST_PERSON) {
            scale = 8;
        }
        if((cameraFlags & CAM_FLAG_PLAYER_AXIS) && (
        (cameraMode == 0x42) //normal
        || (cameraMode == 0x45) //bike
        || (cameraMode == 0x49) //combat
        || (cameraMode == 0x4B) //climb
        //|| (cameraMode == 0x4C) //cutscene
        //|| (cameraMode == 0x4D) //speaking
        //|| (cameraMode == 0x50) //crawling
        || (cameraMode == 0x52) //aiming, holding L
        //|| (cameraMode == 0x53) //Drakor, riding CloudRunner in DR
        //|| (cameraMode == 0x56) //Arwing
        )) {
            _camDoRotateAroundPlayer(stickX, stickY);
        }
        else {
            pCamera->pos.xf.rotation.x += stickX * 128 * scale * timeDelta;
            pCamera->pos.xf.rotation.y += stickY *  16 * scale * timeDelta;
        }
    }
    camOverrideValid = 0;
}

void _drawDebugInfo() {
    float px=pCamera->pos.xf.pos.x, py=pCamera->pos.xf.pos.y,
        pz=pCamera->pos.xf.pos.z;
    s16 rx=pCamera->pos.xf.rotation.x, ry=pCamera->pos.xf.rotation.y,
        rz=pCamera->pos.xf.rotation.z;
    debugPrintfxy(24, 400, "X\t%6d\t%3d", (int)px, (int)(rx / (65535.0 / 360.0)));
    debugPrintfxy(24, 411, "Y\t%6d\t%3d", (int)py, (int)(ry / (65535.0 / 360.0)));
    debugPrintfxy(24, 422, "Z\t%6d\t%3d", (int)pz, (int)(rz / (65535.0 / 360.0)));
}

void _applyOverride() {
    if(camOverrideValid) {
        pCamera->pos.xf.pos.x = camOverrideX;
        pCamera->pos.xf.pos.y = camOverrideY;
        pCamera->pos.xf.pos.z = camOverrideZ;
        if(debugCameraMode == CAM_MODE_FREE) {
            pCamera->pos.xf.rotation.x = camOverrideRX;
            pCamera->pos.xf.rotation.y = camOverrideRY;
            pCamera->pos.xf.rotation.z = camOverrideRZ;
        }
    }
}

void _updateOverride() {
    camOverrideX  = pCamera->pos.xf.pos.x;
    camOverrideY  = pCamera->pos.xf.pos.y;
    camOverrideZ  = pCamera->pos.xf.pos.z;
    camOverrideRX = pCamera->pos.xf.rotation.x;
    camOverrideRY = pCamera->pos.xf.rotation.y;
    camOverrideRZ = pCamera->pos.xf.rotation.z;
    camOverrideValid = 1;
}

//update camera in Stay and Free modes
void _doStayOrFree(u32 bHeld, u32 bPressed) {
    //calculate movement scale
    float scale = ((bHeld & PAD_TRIGGER_Z) ? 2 : 1) * timeDelta;
    float srx = scale * 10.0 * ((cameraFlags & CAM_FLAG_INVERT_X) ? -1.0 : 1.0);
    float sry = scale * 10.0 * ((cameraFlags & CAM_FLAG_INVERT_Y) ? -1.0 : 1.0);
    float spx = scale * -0.25;
    float spy = scale *  0.05;
    float spz = scale *  0.25;

    //apply deadzones
    int sx = controllerStates[3].stickX;
    int sy = controllerStates[3].stickY;
    int cx = controllerStates[3].substickX;
    int cy = controllerStates[3].substickY;
    int tl = controllerStates[3].triggerLeft;
    int tr = controllerStates[3].triggerRight;
    if(sx < CAMERA_LSTICK_DEADZONE && sx > -CAMERA_LSTICK_DEADZONE) sx = 0;
    if(sy < CAMERA_LSTICK_DEADZONE && sy > -CAMERA_LSTICK_DEADZONE) sy = 0;
    if(cx < CAMERA_RSTICK_DEADZONE && cx > -CAMERA_RSTICK_DEADZONE) cx = 0;
    if(cy < CAMERA_RSTICK_DEADZONE && cy > -CAMERA_RSTICK_DEADZONE) cy = 0;
    if(tl < CAMERA_TRIGGER_DEADZONE) tl = 0;
    if(tr < CAMERA_TRIGGER_DEADZONE) tr = 0;

    //apply rotation
    pCamera->pos.xf.rotation.x += srx * cx;
    pCamera->pos.xf.rotation.y += sry * cy;

    //apply Y translation (movement)
    pCamera->pos.xf.pos.y += spy * (tr - tl);

    //calculate XZ movement vector
    float tx = spx * sx;
    float tz = spz * sy; //not sz, since it's analog stick input
    //X here is actually the rotation around the Y axis...
    float sinR = sinf((float)pCamera->pos.xf.rotation.x * S16_TO_RADIANS);
    float cosR = cosf((float)pCamera->pos.xf.rotation.x * S16_TO_RADIANS);

    pCamera->pos.xf.pos.x += (tx * cosR) - (tz * sinR);
    pCamera->pos.xf.pos.z += (tx * sinR) + (tz * cosR);
}

//update camera in Bird's Eye mode
void _doBird(u32 bHeld, u32 bPressed) {
    vec3f targetPos;
    float targetXZ;

    //follow the target
    if(pCamera->focus) {
        pCamera->pos.xf.pos.x = pCamera->focus->pos.pos.x;
        pCamera->pos.xf.pos.y = pCamera->focus->pos.pos.y + camOverrideDist;
        pCamera->pos.xf.pos.z = pCamera->focus->pos.pos.z;
        if(getArwing()) {
            pCamera->pos.xf.rotation.x = -pCamera->focus->pos.rotation.x;
            pCamera->pos.xf.rotation.y = 0x4000;
        }
        else {
            pCamera->pos.xf.rotation.x = -0x8000 - pCamera->focus->pos.rotation.x;
            pCamera->pos.xf.rotation.y = 0x4000;
        }
        if(camOverrideDist < 0) pCamera->pos.xf.rotation.y = -pCamera->pos.xf.rotation.y;
    }
    _camDoCStick();

    //L/R to zoom
    int tl = controllerStates[3].triggerLeft;
    int tr = controllerStates[3].triggerRight;
    if(tl < CAMERA_TRIGGER_DEADZONE) tl = 0;
    if(tr < CAMERA_TRIGGER_DEADZONE) tr = 0;
    float scale = timeDelta * 0.01;
    camOverrideDist += (tr - tl) * ((bHeld & PAD_TRIGGER_Z) ? 2 : 1) * scale;
    //if(tl != tr) debugPrintf("Dist %f\n", camOverrideDist);
}

//handle camera in First Person mode
void _doFirstPerson(u32 bHeld, u32 bPressed) {
    if(pCamera->focus) {
        float height = cameraMtxVar57 ? cameraMtxVar57->targetHeight : 0;
        pCamera->pos.xf.pos.x = pCamera->focus->pos.pos.x;
        //fudge factor to be above character's head instead of inside it
        pCamera->pos.xf.pos.y = pCamera->focus->pos.pos.y + height + 8;
        pCamera->pos.xf.pos.z = pCamera->focus->pos.pos.z;
        if(getArwing()) {
            pCamera->pos.xf.rotation.x = -pCamera->focus->pos.rotation.x;
            pCamera->pos.xf.rotation.y = pCamera->focus->pos.rotation.y;
            pCamera->pos.xf.rotation.z = pCamera->focus->pos.rotation.z;
        }
        else {
            pCamera->pos.xf.rotation.x = -0x8000 - pCamera->focus->pos.rotation.x;
            pCamera->pos.xf.rotation.y = -pCamera->focus->pos.rotation.y;
            pCamera->pos.xf.rotation.z = -pCamera->focus->pos.rotation.z;
        }
        //this works but doesn't undo when you exit
        //XXX how does it work when you do the actual first person view?
        //if(pCamera->focus->newOpacity > 64) pCamera->focus->newOpacity = 64;
    }
    _camDoCStick();
}

//handle camera in Orbit mode
void _doOrbit(u32 bHeld, u32 bPressed) {
    if(!pCamera->focus) return;

    s8 stickX, stickY;
    _camGetStickInput(&stickX, &stickY);
    camOrbitAngXZ += stickX * timeDelta * 10;
    camOrbitAngY  += stickY * timeDelta * 10;
    camOrbitDist  += (controllerStates[3].triggerLeft -
        controllerStates[3].triggerRight) * timeDelta * 0.1;

    float height = cameraMtxVar57 ? cameraMtxVar57->targetHeight : 0;
    float mz = sinf(pi * -(camOrbitAngXZ - 0x4000) / 32768.0);
    float mx = cosf(pi * -(camOrbitAngXZ - 0x4000) / 32768.0);
    float my = sinf(pi * -camOrbitAngY / 32768.0);
    float dy = cosf(pi * -camOrbitAngY / 32768.0) * camOrbitDist;

    pCamera->pos.xf.pos.x = pCamera->focus->pos.pos.x + dy * mx;
    pCamera->pos.xf.pos.y = pCamera->focus->pos.pos.y + height + camOrbitDist * my;
    pCamera->pos.xf.pos.z = pCamera->focus->pos.pos.z + dy * mz;
    _lookAtTarget();
}

//replaces a call to the update method of the current camera DLL.
void cameraUpdateHook() {
    //r12 is the address it was about to jump to, which depends on the mode.
    //GET_REGISTER(12, origFunc);

    //do this in all modes so that we don't carry over stale button states
    //when changing modes
    static u32 prevBtn4 = 0;
    u32 bHeld = controllerStates[3].button;
    u32 bPressed = bHeld & ~prevBtn4;
    prevBtn4 = bHeld;

    /*CameraPosition *pos = &cameraPositions[camera_playerNo];
    debugPrintf("Cam%d @ " DPRINT_FIXED "%f %f %f\n" DPRINT_NOFIXED,
        camera_playerNo, pos->xf.pos.x, pos->xf.pos.y, pos->xf.pos.z);
    char name[16];
    getObjName(name, pos->pMatrix);
    debugPrintf("30: %08X %s\n", pos->pMatrix, name);
    debugPrintf("34: %08X 38:%f %f %f 56:%04X %08X %08X\n",
        *(u32*)(&pos->unk34), pos->unk38, *(float*)(&pos->unk3C), pos->unk40,
        *(u16*)(&pos->unk56), *(u32*)(&pos->unk58), *(u32*)(&pos->unk5C));*/

    /*static const u16 offsets[] = {0x30, 0xA4, 0x11C, 0x124, 0x128, 0};
    static const char *names[] = {
        "unk30", "focus", "overd", "targt", "tPrev"};
    for(int i=0; offsets[i]; i++) {
        char name[16];
        ObjInstance *obj = *(ObjInstance**)(((void*)pCamera) + offsets[i]);
        getObjName(name, obj);
        debugPrintf(DPRINT_FIXED "%s %08X %s\n" DPRINT_NOFIXED,
            names[i], obj, name);
    }*/

    if(debugCameraMode == CAM_MODE_NORMAL || bHeld & PAD_BUTTON_A) {
        //origFunc(pCamera);
        _camDoCStick();
        cameraUpdateViewMtx(pCamera);
        //updateViewMatrix();
        return;
    }

    _applyOverride();

    if(debugCameraMode == CAM_MODE_STAY || bHeld & PAD_BUTTON_Y) {
        _lookAtTarget();
    }

    switch(debugCameraMode) {
        case CAM_MODE_STAY:
        case CAM_MODE_FREE:
            _doStayOrFree(bHeld, bPressed);
            break;
        case CAM_MODE_ORBIT: _doOrbit(bHeld, bPressed); break;
        case CAM_MODE_BIRD: _doBird(bHeld, bPressed); break;
        case CAM_MODE_FIRST_PERSON: _doFirstPerson(bHeld, bPressed); break;
        default: break;
    }

    //debugPrintf(DPRINT_FIXED "S %d %d C %d %d L %d R %d\n" DPRINT_NOFIXED,
    //    controllerStates[3].stickX,      controllerStates[3].stickY,
    //    controllerStates[3].substickX,   controllerStates[3].substickY,
    //    controllerStates[3].triggerLeft, controllerStates[3].triggerRight);

    //update camera
    cameraUpdateViewMtx(pCamera);
    //updateViewMatrix();
    _drawDebugInfo();
    _updateOverride();
}

int padGetCxHook(int pad) {
    //replaces the body of padGetCX().
    if(joypadDisable || isDvdDriveBusy) return 0;
    if((pad == 0) && !(cameraFlags & CAM_FLAG_PAD3)) {
        //we use C stick to move camera
        //this means we don't want other things to react to the C stick
        u16 buttons = controllerStates[pad + (whichControllerFrame * 4)].button;
        if(buttons & PAD_BUTTON_LEFT)  return -16;
        if(buttons & PAD_BUTTON_RIGHT) return  16;
        return 0;
    }
    return controllerStates[pad + (whichControllerFrame * 4)].substickX;
}

int padGetCyHook(int pad) {
    //replaces the body of padGetCY().
    if(joypadDisable || isDvdDriveBusy) return 0;
    if((pad == 0) && !(cameraFlags & CAM_FLAG_PAD3)) {
        u16 buttons = controllerStates[pad + (whichControllerFrame * 4)].button;
        if(buttons & PAD_BUTTON_UP)   return  16;
        if(buttons & PAD_BUTTON_DOWN) return -16;
        return 0;
    }
    return controllerStates[pad + (whichControllerFrame * 4)].substickY;
}

//XXX check if cannon is inverted by default like viewfinder is.
int padGetStickXHook(int pad) {
    //replaces the body of padGetStickX().
    if(joypadDisable || isDvdDriveBusy) return 0;
    int result = controllerStates[pad + (whichControllerFrame * 4)].stickX;
    u16 buttons = controllerStates[pad + (whichControllerFrame * 4)].button;

    //mode 0x52 is both holding L button and aiming with staff,
    //and pushing blocks.
    void *pState = pPlayer ? pPlayer->state : NULL;
    u16 stateNo = pState ? *(u16*)(pState + 0x274) : 0;
    //don't invert controls when pushing a block
    if(stateNo == 0x1D) return result;

    if((cameraFlags & CAM_FLAG_INVERT_X) && !(buttons & PAD_TRIGGER_L)) {
        if(cameraMode == 0x52    //staff aiming
        || cameraMode == 0x44    //viewfinder
        || cameraMode == 0x51) { //aim cannon
            return -result;
        }
    }
    return result;
}

int padGetStickYHook(int pad) {
    //replaces the body of padGetStickY().
    if(joypadDisable || isDvdDriveBusy) return 0;
    int result = controllerStates[pad + (whichControllerFrame * 4)].stickY;
    u16 buttons = controllerStates[pad + (whichControllerFrame * 4)].button;

    void *pState = pPlayer ? pPlayer->state : NULL;
    u16 stateNo = pState ? *(u16*)(pState + 0x274) : 0;
    //don't invert controls when pushing a block
    if(stateNo == 0x1D) return result;

    if(cameraMode == 0x44) { //viewfinder
        //already inverted by default, so do opposite
        if(!(cameraFlags & CAM_FLAG_INVERT_Y)) return -result;
    }
    else if((cameraFlags & CAM_FLAG_INVERT_Y) && !(buttons & PAD_TRIGGER_L) && (
    cameraMode == 0x52 || cameraMode == 0x51)) {
        return -result;
    }
    return result;
}

u32 minimapButtonHeldHook(int pad) {
    //replaces a call to getButtonsHeld() in minimap update routine.
    if(cameraFlags & CAM_FLAG_PAD3) {
        //we don't need to change anything
        return getButtonsHeld(pad);
    }
    return 0;
}
u32 minimapButtonPressedHook(int pad) {
    //replaces a call to getButtonsJustPressed() in minimap update routine.
    if(cameraFlags & CAM_FLAG_PAD3) {
        //we don't need to change anything
        return getButtonsJustPressed(pad);
    }
    return 0;
}

int viewFinderZoomHook(int pad) {
    //replaces a call to padGetCY() in viewfinder routine.
    if(cameraFlags & CAM_FLAG_PAD3) {
        //we don't need to change anything
        return padGetCY(pad);
    }
    //remap to L/R, since D-pad is slow and digital.
    int tl = controllerStates[pad].triggerLeft;
    int tr = controllerStates[pad].triggerRight;
    if(tl < CAMERA_TRIGGER_DEADZONE) tl = 0;
    if(tr < CAMERA_TRIGGER_DEADZONE) tr = 0;
    return tl - tr;
}
